<h1> C++NewFeatures</h1>

# 1. long long类型
长整型，最小64位。

# 2. 列表初始化 
以花括号的方式进行初始化。
通常C++的几种不同的初始化方式可以相互等价的使用。但如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。
```c++
std::vector<std::string> v1{"a","an","the"};   //--正确
std::vector<std::string> v2( "a","an","the" ); //--错误
```

# 3. 空指针
空指针不使用任何对象，几个生成空指针的方法：
```c++
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;
```
最直接的方法是用字面值nullptr来初始化指针，C++11新标准中引入的方法。nullptr指针是一种特殊类型的字面值，可以被转换成任意其他的指针类型。

# 4. constexpr与常量表达式

常量表达式（const expression）是指值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。

常量表达式：
```c++
const int max_files = 20;
const int limit = max_files + 1;
```

非常量表达式：
```c++
int staff_size = 20;
const int sz = get_size();
```
尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而不是const int，所以它不属于常量表达式。另外，尽管sz本身是一个常量，但它的具体值要到运行时才能获取到，所以也不是常量表达式。

constexpr变量
在一个复杂系统中，很难（几乎不可能）分辨一个初始值到底是不是一个常量表达式。c++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

```c++
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size(); //--当size()是一个constexpr函数时才是一条正确的声明
```

常量表达式的值需要在编译时就计算得到，声明constexpr时用到的类型必须为“字面值类型”。基本数据类型，算术类型，引用和指针都属于字面值类型。

尽管指针和引用都能定义成constexpr，但它们的初始值受到严格限制。一个constexpr指针的初始值必须是nullptr或者0或者存储于某个固定地址中的对象。

# 5. 类型别名声明

类型别名(type alias)是一个名字，它是某种类型的同义词。
有两种方法可用于定义类型别名，传统的方法是使用关键字 typedef:

```c++
typedef double wages;	//--wages是double的同义词
typedef wages base, *p;	//--base是double的同义词，p是double *的同义词
```
新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名：
```c++
using SI = Sales_item;  //--SI是Sales_item的同义词
```

# 6. auto类型说明符
编程时常常需要把表达式的值赋值给变量，这就要求在声明变量的时候，清楚的知道表达式的类型。然而做到这一点并不容易，为了解决这个问题c++新标准引入了auto类型说明符，用它让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型。
编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当的改变结果类型，使其更符合初始化规则。

首先，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时，编译器以引用对象的类型作为auto类型：

```c++
int i = 0, &r = i;
auto a = r; //--a是一个整数
```

其次，auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时：

```c++
const int ci = i, &cr = ci;
auto b = ci;	//--b是一个整数（ci的顶层const特性被忽略掉了）
auto c = cr;    //--c是一个整数（cr是ci的别名，ci本身是一个顶层const）
auto d = &i;    //--d是整型指针
auto e = &ci;   //--e是一个指向整数常量的指针（对常量对象取对象是一种底层const）
```
如果希望推倒出来的auto类型是一个顶层const，需要明确指出：

```c++
const auto f = ci; //--ci的推演类型是int，f是const int
```

还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：

```c++
auto & g = ci;			//--g是一个整型常量引用，绑定到ci
auto & h = 42;			//--错误：不能为非常量引用绑定字面值
const auto & j = 42;	//--正确：可以为常量引用绑定字面值
```

要在一条语句中定义多个变量时，切记，符号&和*只从属于某个声明符，而非基本数据类型的一部分，因此，初始值必须是同一种类型。

```c++
auto k = ci, &l = i;     //--k是整数，l是整型引用
auto &m = ci, *p = &ci;  //--m是对整型常量的引用，p是指向整型常量的指针
auto &n = i, *p2 = &ci;  //--错误:i的类型是int，而&ci的类型是const int
```
注：
顶层const与底层const:
指针本身是一个对象，它又可以指向另外一个对象。因此指针是不是一个常量及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const(top-level const)表示指针本身是一个常量，用名词底层const(low-level const)表示指针所指的对象是一个常量。

# 7. decltype类型指示符
有时希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。

```c++
decltype(f()) sum = x; //--sum的类型就是函数f()的返回类型
```

# 8. 类内初始化
C++新标准规定，可以为数据成员提供一个类内初始化值，创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。需要注意的是，初始化时，或者放在花括号里，或者放在等号右边，不能使用圆括号。

# 9. 范围for语句
C++11使用范围for语句遍历给定序列中的每个元素，并对序列中的每个值执行某种操作，语法形式为：
```c++
for(declaration:expression)
   statement
```

其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。

# 10. 容器的cbegin和cend函数

容器中,begin和end返回的具体类型由对象是否是常量决定,如果对象是常量,它们返回的是const_iterator;如果对象不是常量，则返回iterator。

```c++
vector<int> v;
const vector<int> cv;
auto it1 = v.begin();  //--it1的返回类型是vector<int>::iterator
auto it2 = cv.begin(); //--it2的返回类型是vector<int>::const_iterator
```
有时候这种默认的行为并不是我们想要的,有时只想要常量类型。为了便于专门得到const_iterator类型的返回值，c++11中引入了两个新函数，分别是cbegin(),cend()。不论容器对象本身是否是常量，返回值都是const_iterator。

# 11. 标准库函数begin和end
使用指针遍历数组时，为了方便首尾指针，c++11中引入两个名为begin和end的库函数，这两个函数与容器中的两个同名成员功能相似，但是使用数组作为它们的参数。

```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9};
int * beg = begin(ia);  //--指向ia首元素地址
int * last = end(ia);	//--指向ia尾元素的下一位置的地址
```

# 12. 将sizeof用于类成员

C++11新标准允许我们使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问类的成员，但是sizeof无须我们提供一个具体的对象，因为要想知道类成员的大小无须真的获取该成员。

```c++

class Sales_data 
{
public:
	int revenue;
};

auto n = sizeof Sales_data::revenue;
```

# 13. 标准库initializer_list类

如果函数的实参数量未知但是全部实参的类型都相同时，可以使用initializer_list类型的形参，实现可变长参数函数。initializer_list是一种模版类型，定义initializer_list对象时，必须指明列表中所含元素的类型。而且initializer_list对象中的元素永远是常量值。

```c++
void error_msg(initializer_list<string> il) 
{
	for (auto & i:il) 
	{
		cout << i.c_str() << " ";
	}

	cout << endl;
}

error_msg({"level1 ","level2","level3"});  //--调用方式

```

# 14. 列表初始化返回值

c++11新标准规定，函数可以返回花括号包围的值的列表。类似于其它返回结果，此处的列表也用来对表示函数返回值的临时量进行初始化。如果列表为空，临时量执行初始化；否则，返回的值由函数的返回类型决定。

```c++
vector<string> process(int type) 
{

	if (0==type) 
	{
		return{ "type0" };
	}
	else 
	{
		return{ "type1", "type 2", "type 3" };
	}
}

```

如果函数返回的值是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。


# 15. 尾置返回类型

有点鸡肋。

# 16. constexpr函数

constexpr函数是指能用于constexpr表达式的函数。遵循：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条语句。

```c++
constexpr int new_sz() { return 42; }

constexpr int foo = new_sz();  //--常量表达式
```

允许constexpr函数的返回值并非一个常量：

```c++
constexpr int new_sz() { return 42; }
constexpr size_t scale(size_t cnt) { return new_sz()*cnt; }

int arr[scale(2)];  //--正确
int i = 2;
int arr2[scale(i)];  //--错误：scale(i)不是常量表达式
```

当scale的实参是常量表达式时，返回值也是常量表达式，反之则不然。

# 17. 使用=default生成默认构造函数

c++中，如果我们为一个类已经定义了其他构造函数，那么也必须定义一个默认构造函数。在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上=default来要求编译器生成默认构造函数。

# 18. 委托构造函数

C++新标准扩展了构造函数初始值的功能，称做委托构造函数。一个委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程，或者说它把自己的一些（或全部）职责委托给了其他构造函数。

如：
```c++

class Sales_data
{
public:

	Sales_data(string s,unsigned cnt,double price) {}

	Sales_data() :Sales_data("",0,0) {}

	Sales_data(string s) :Sales_data(s,0,0) {}

	Sales_data(double price) :Sales_data() {}
};
```

当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行，然后控制权交还给委托者的函数体。


# 19. constexpr构造函数

TO DO。。。


# 20. array和forward_list顺序容器

常用的顺序容器有：

+ vector  可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢
+ deque  双端队列，支持快速随机访问，在头尾位置插入或删除速度很快
+ list   双向链表，只支持双向顺序访问，在任何位置进行插入/删除操作都很快
+ string 与vector相似的容器，但专门用于保存字符
  
另外c++11新增了两个容器：
+ forward_list 单向链表，只支持单向顺序访问，在任何位置进行插入/删除操作都很快
+ array 固定大小数组，支持快速随机访问，不能添加和删除元素

通常，使用vector是最好的选择，除非你有很好的理由选择其它容器。如程序要求在容器的中间插入或删除元素，可使用list或forward_list。

# 21. 容器的非成员函数swap

从c++11起，提供泛化版的swap函数。swap操作交换两个相同类型容器的内容。
注意：
除array以外，swap不对任何元素进行拷贝、删除或插入操作。swap只是交换了两个容器的内部数据结构。

# 22. 使用insert的返回值

在旧版本的标准库中，insert操作的返回值是void，新版本返回指向第一个新加入元素的迭代器。


# 23. 使用emplace操作

新标准引入3个新成员——emplace_front,emplace,emplace_back。这些操作构造而不是拷贝元素。这些操作分别对应push_front,insert,push_back，允许把元素放在容器头部，一个指定位置之前或容器尾部。
当调用push或insert时把元素类型的对象传递给它们，这些对象被拷贝到容器中。
而当调用一个emplace成员时，则是将参数传递给元素类型的构造函数，emplace成员使用这些参数在容器管理的内存空间中直接构造元素。需注意，参数必须与元素类型的构造函数匹配。


# 24. shrink_to_fit函数

在新标准库中，可以调用shrink_to_fit来要求deque，vector，或string退回不需要的内存空间。此函数指出我们不需要多余的内存空间，但是，具体的实现可以忽略此请求，调用shrink_to_fit也并不保证一定退回内存空间。

# 25. lambda表达式

新标准中引入了lambda表达式，一个lambda表达式表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数。与任何函数类似，一个lambda具有一个返回类型，一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部，一个lambda表达式形式为：

```
[capture list] (parameter list) -> return type { function body }
```
其中capture list是一个lambda所在函数中定义的局部变量的列表（通常为空），return type,parameter list,function body与任何普通函数一样。

可以忽略参数列表和返回值类型，但必须永远包含捕获列表和函数体：

```
auto f = [] {return 42; };
```

忽略括号和参数列表等价于指定一个空参数列表。如果忽略返回类型，lambda根据函数体中的代码推断出返回类型，如果没有return语句，则返回类型为void。

一个lambda通过将局部变量包含在其捕获列表中使用这些变量，捕获列表指引lambda在其内部包含访问局部变量所需的信息。

# 26. 标准库bind函数

新标准中引入bind函数，进行参数绑定。可以将bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。
调用bind的一般形式为：

```
auto newCallable=bind(callable,arg_list)
```

其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list。arg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是占位符，表示newCallabel的参数，它们占据了传递给newCallable的参数的“位置”。如：_1为newCallable的第一个参数，_2为第二个参数，依此类推。

如：
```c++
void f_be_bind(int a,int b ,int c,int d ,int e) 
{

	cout << "a:"<<a<<" ,b:"<<b<<",c:"<<c<<",d:"<<d<<",e:"<<e <<endl;
}

auto f_bind = bind(f_be_bind,1,_2,3,4,_1);

	f_bind(5, 2);

```

f_be_bind有5个参数，第一个参数被绑定为1，第三个参数被绑定为3，第四个参数为4，而第二个参数被绑定为新函数对象的第二个参数，第五个参数被绑定为新函数对象的第一个参数。

须知,_1,_2等占位符，在std::placeholders名字空间使用。

  
# 27. 无序容器

c++11提供了四种无序容器：

+ unordered_map
+ unordered_set
+ unordered_multimap
+ unordered_multiset

无序容器和有序容器有相同的操作，无序容器使用哈希函数进行组织，而普通容器使用红黑树进行组织。

# 28. 智能指针

为了更容易，也更安全的使用动态内存，新的标准中提供了两种智能指针类型为管理动态对象。shared_ptr允许多个指针指向同一个对象，unique_ptr则“独占”所指向的对象。

shared_ptr和unique_ptr实际上是模版类，分别结合make_shared和make_unique模版函数，能消除显示的new,delete操作。

注:make_unique是在C++14里引入的。

还有一个为了在特定场合使用的weak_ptr指针。weak_ptr是一种不控制所指向对象生存周期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数.一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放,即使有weak_ptr指向对象。

weak_ptr的使用场合可以参考文章：

[智能指针](https://www.jianshu.com/p/bf8de014e5c2)

使用shared_ptr可能因循环引用而导致内存泄露，可以使用weak_ptr对资源时行监控。

# 29. 将=default用于拷贝控制成员

我们可以通过将拷贝控制成员定义为=default来显示的要求编译器生成合成（默认）的版本。

```c++

class SalesData 
{
public:
	SalesData() = default; //--内联函数

	SalesData(const SalesData &) = default;

	SalesData & operator=(const SalesData &);

	~SalesData() = default;
};

SalesData & SalesData::operator=(const SalesData &) = default;  //--非内联函数

```

当在内中使用 = default修饰时,合成函数隐式声明为内联的，如果想不为内联，应该在类外定义。

对于拷贝构造函数，拷贝赋值运算符和析构函数，C++语言并不要求我们定义所有这些操作。那怎么决定是否定义？

+ 需要析构函数的类也需要定义拷贝和赋值操作
  
  通常，是否需要析构函数会很明显，如需要释放动态申请的内存。如果一个类需一个析构函数时，几乎可以肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。因为，通常意味着有引用类型，需要深层拷贝。 

+ 需要拷贝操作的类也需要赋值操作，反之亦然
  
  如果一个类需要拷贝构造函数，几乎可以肯定需要拷贝赋值运算符，反之亦然。但是不一定需要析构函数。


# 使用=delete阻止拷贝类对象

虽然大多数类应该定义拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。为了阻止拷贝，看起来可能应该不定义拷贝控制成员。但是，这种策略是无效的：如果我们的类未定义这些操作，编译器为它生成默认的版本。

在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数(deleted function)来阻止拷贝。删除的函数是指:我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加在=delete来指出我们希望将它定义成为删除的：

```c+++
class NoCopy 
{
	NoCopy() = default;
	NoCopy(const NoCopy &) = delete; //--阻止拷贝
	NoCopy  & operator =(const NoCopy &) = delete; //--阻止赋值
	~NoCopy() = default;
};
```
需要注意：

+ 与=default不同，=delete必须出现在函数第一次声明的时候；
+ 与=default不同，我们可以对任何函数指定=delete，虽然删除函数主要用途是用来阻止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的；
+ 不能删除析构函数，如果析构函数被删除，就无法销毁此类型的对象了；
+ 在新标准之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝。

# 用移动类对象来代替拷贝类对象

假设我们自己要为一个string数组写一个重新分配内存的成员函数，忽略具体细节，它应该：
+ 为一个新的、更大的string数组分配内存
+ 在内存空间的前一部分构造对象，保存现有元素
+ 销毁原内存空间中的元素，并释放这块内存
  
可以看到，重新分配内存空间时，会把string从旧内存空间拷贝到新内存空间，而string具有类值行为，拷贝时会有两个副本，而拷贝完后再删除原有副本。因此，拷贝这些string中的数据是多余的，在重新分配内存空间时，如果我们避免分配和释放string的开销，性能会有很大提升。

通过使用新标准库引入的两种机制，我们可以避免string的拷贝。

+ 第一个机制：移动构造函数

有一些标准类库，包括string，都定义了所谓的”移动构造函数“。移动构造函数如何工作和具体实现细节都未公布。但是，移动构造函数通常是将资源从给定对象”移动“而不是拷贝到正在创建的对象。而且，标准库保证”移后源“(moved-from)仍然保持一个有效的，可析构状态。对于string，可以想象每个string都有一个指向char数组的指针。可以假定string的移动构造函数进行了指针的拷贝，而不是为字符分配内存空间然后拷贝字符。

+ 第二个机制：std::move函数

1） 调用move函数表示希望使用移动构造函数，如果漏掉了move调用，将会使用拷贝构造函数； 
2） 通常不会为move调用using声明（TODO,为什么？），使用时，直接调用std::move而不是move。

