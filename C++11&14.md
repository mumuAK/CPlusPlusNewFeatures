# C++NewFeatures

## long long类型
长整型，最小64位。

##列表初始化 
以花括号的方式进行初始化。
通常C++的几种不同的初始化方式可以相互等价的使用。但如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。
```c++
std::vector<std::string> v1{"a","an","the"};   //--正确
std::vector<std::string> v2( "a","an","the" ); //--错误
```

##空指针
空指针不使用任何对象，几个生成空指针的方法：
```c++
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;
```
最直接的方法是用字面值nullptr来初始化指针，C++11新标准中引入的方法。nullptr指针是一种特殊类型的字面值，可以被转换成任意其他的指针类型。

##constexpr与常量表达式

常量表达式（const expression）是指值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。

常量表达式：
```c++
const int max_files = 20;
const int limit = max_files + 1;
```

非常量表达式：
```c++
int staff_size = 20;
const int sz = get_size();
```
尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而不是const int，所以它不属于常量表达式。另外，尽管sz本身是一个常量，但它的具体值要到运行时才能获取到，所以也不是常量表达式。

constexpr变量
在一个复杂系统中，很难（几乎不可能）分辨一个初始值到底是不是一个常量表达式。c++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

```c++
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size(); //--当size()是一个constexpr函数时才是一条正确的声明
```

常量表达式的值需要在编译时就计算得到，声明constexpr时用到的类型必须为“字面值类型”。基本数据类型，算术类型，引用和指针都属于字面值类型。

尽管指针和引用都能定义成constexpr，但它们的初始值受到严格限制。一个constexpr指针的初始值必须是nullptr或者0或者存储于某个固定地址中的对象。

##类型别名声明

类型别名(type alias)是一个名字，它是某种类型的同义词。
有两种方法可用于定义类型别名，传统的方法是使用关键字 typedef:

```c++
typedef double wages;	//--wages是double的同义词
typedef wages base, *p;	//--base是double的同义词，p是double *的同义词
```
新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名：
```c++
using SI = Sales_item;  //--SI是Sales_item的同义词
```

## auto类型说明符
编程时常常需要把表达式的值赋值给变量，这就要求在声明变量的时候，清楚的知道表达式的类型。然而做到这一点并不容易，为了解决这个问题c++新标准引入了auto类型说明符，用它让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型。
编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当的改变结果类型，使其更符合初始化规则。

首先，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时，编译器以引用对象的类型作为auto类型：

```c++
int i = 0, &r = i;
auto a = r; //--a是一个整数
```

其次，auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时：

```c++
const int ci = i, &cr = ci;
auto b = ci;	//--b是一个整数（ci的顶层const特性被忽略掉了）
auto c = cr;    //--c是一个整数（cr是ci的别名，ci本身是一个顶层const）
auto d = &i;    //--d是整型指针
auto e = &ci;   //--e是一个指向整数常量的指针（对常量对象取对象是一种底层const）
```
如果希望推倒出来的auto类型是一个顶层const，需要明确指出：

```c++
const auto f = ci; //--ci的推演类型是int，f是const int
```

还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：

```c++
auto & g = ci;			//--g是一个整型常量引用，绑定到ci
auto & h = 42;			//--错误：不能为非常量引用绑定字面值
const auto & j = 42;	//--正确：可以为常量引用绑定字面值
```

要在一条语句中定义多个变量时，切记，符号&和*只从属于某个声明符，而非基本数据类型的一部分，因此，初始值必须是同一种类型。

```c++
auto k = ci, &l = i;     //--k是整数，l是整型引用
auto &m = ci, *p = &ci;  //--m是对整型常量的引用，p是指向整型常量的指针
auto &n = i, *p2 = &ci;  //--错误:i的类型是int，而&ci的类型是const int
```
注：
顶层const与底层const:
指针本身是一个对象，它又可以指向另外一个对象。因此指针是不是一个常量及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const(top-level const)表示指针本身是一个常量，用名词底层const(low-level const)表示指针所指的对象是一个常量。

## decltype类型指示符
有时希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。

```c++
decltype(f()) sum = x; //--sum的类型就是函数f()的返回类型
```

## 类内初始化
C++新标准规定，可以为数据成员提供一个类内初始化值，创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。需要注意的是，初始化时，或者放在花括号里，或者放在等号右边，不能使用圆括号。

## 范围for语句
C++11使用范围for语句遍历给定序列中的每个元素，并对序列中的每个值执行某种操作，语法形式为：
```c++
for(declaration:expression)
   statement
```

其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。

## 容器的cbegin和cend函数

容器中,begin和end返回的具体类型由对象是否是常量决定,如果对象是常量,它们返回的是const_iterator;如果对象不是常量，则返回iterator。

```c++
vector<int> v;
const vector<int> cv;
auto it1 = v.begin();  //--it1的返回类型是vector<int>::iterator
auto it2 = cv.begin(); //--it2的返回类型是vector<int>::const_iterator
```
有时候这种默认的行为并不是我们想要的,有时只想要常量类型。为了便于专门得到const_iterator类型的返回值，c++11中引入了两个新函数，分别是cbegin(),cend()。不论容器对象本身是否是常量，返回值都是const_iterator。

标准库函数begin和end
使用指针遍历数组时，为了方便首尾指针，c++11中引入两个名为begin和end的库函数，这两个函数与容器中的两个同名成员功能相似，但是使用数组作为它们的参数。

```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9};
int * beg = begin(ia);  //--指向ia首元素地址
int * last = end(ia);	//--指向ia尾元素的下一位置的地址
```
