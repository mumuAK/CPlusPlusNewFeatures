<h1> C++NewFeatures</h1>

# 1. long long类型
长整型，最小64位。

# 2. 列表初始化 
以花括号的方式进行初始化。
通常C++的几种不同的初始化方式可以相互等价的使用。但如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。
```c++
std::vector<std::string> v1{"a","an","the"};   //--正确
std::vector<std::string> v2( "a","an","the" ); //--错误
```

# 3. 空指针
空指针不使用任何对象，几个生成空指针的方法：
```c++
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;
```
最直接的方法是用字面值nullptr来初始化指针，C++11新标准中引入的方法。nullptr指针是一种特殊类型的字面值，可以被转换成任意其他的指针类型。

# 4. constexpr与常量表达式

常量表达式（const expression）是指值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。

常量表达式：
```c++
const int max_files = 20;
const int limit = max_files + 1;
```

非常量表达式：
```c++
int staff_size = 20;
const int sz = get_size();
```
尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而不是const int，所以它不属于常量表达式。另外，尽管sz本身是一个常量，但它的具体值要到运行时才能获取到，所以也不是常量表达式。

constexpr变量
在一个复杂系统中，很难（几乎不可能）分辨一个初始值到底是不是一个常量表达式。c++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

```c++
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size(); //--当size()是一个constexpr函数时才是一条正确的声明
```

常量表达式的值需要在编译时就计算得到，声明constexpr时用到的类型必须为“字面值类型”。基本数据类型，算术类型，引用和指针都属于字面值类型。

尽管指针和引用都能定义成constexpr，但它们的初始值受到严格限制。一个constexpr指针的初始值必须是nullptr或者0或者存储于某个固定地址中的对象。

# 5. 类型别名声明

类型别名(type alias)是一个名字，它是某种类型的同义词。
有两种方法可用于定义类型别名，传统的方法是使用关键字 typedef:

```c++
typedef double wages;	//--wages是double的同义词
typedef wages base, *p;	//--base是double的同义词，p是double *的同义词
```
新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名：
```c++
using SI = Sales_item;  //--SI是Sales_item的同义词
```

# 6. auto类型说明符
编程时常常需要把表达式的值赋值给变量，这就要求在声明变量的时候，清楚的知道表达式的类型。然而做到这一点并不容易，为了解决这个问题c++新标准引入了auto类型说明符，用它让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型。
编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当的改变结果类型，使其更符合初始化规则。

首先，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时，编译器以引用对象的类型作为auto类型：

```c++
int i = 0, &r = i;
auto a = r; //--a是一个整数
```

其次，auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时：

```c++
const int ci = i, &cr = ci;
auto b = ci;	//--b是一个整数（ci的顶层const特性被忽略掉了）
auto c = cr;    //--c是一个整数（cr是ci的别名，ci本身是一个顶层const）
auto d = &i;    //--d是整型指针
auto e = &ci;   //--e是一个指向整数常量的指针（对常量对象取对象是一种底层const）
```
如果希望推倒出来的auto类型是一个顶层const，需要明确指出：

```c++
const auto f = ci; //--ci的推演类型是int，f是const int
```

还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：

```c++
auto & g = ci;			//--g是一个整型常量引用，绑定到ci
auto & h = 42;			//--错误：不能为非常量引用绑定字面值
const auto & j = 42;	//--正确：可以为常量引用绑定字面值
```

要在一条语句中定义多个变量时，切记，符号&和*只从属于某个声明符，而非基本数据类型的一部分，因此，初始值必须是同一种类型。

```c++
auto k = ci, &l = i;     //--k是整数，l是整型引用
auto &m = ci, *p = &ci;  //--m是对整型常量的引用，p是指向整型常量的指针
auto &n = i, *p2 = &ci;  //--错误:i的类型是int，而&ci的类型是const int
```
注：
顶层const与底层const:
指针本身是一个对象，它又可以指向另外一个对象。因此指针是不是一个常量及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const(top-level const)表示指针本身是一个常量，用名词底层const(low-level const)表示指针所指的对象是一个常量。

# 7. decltype类型指示符
有时希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。

```c++
decltype(f()) sum = x; //--sum的类型就是函数f()的返回类型
```

# 8. 类内初始化
C++新标准规定，可以为数据成员提供一个类内初始化值，创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。需要注意的是，初始化时，或者放在花括号里，或者放在等号右边，不能使用圆括号。

# 9. 范围for语句
C++11使用范围for语句遍历给定序列中的每个元素，并对序列中的每个值执行某种操作，语法形式为：
```c++
for(declaration:expression)
   statement
```

其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。

# 10. 容器的cbegin和cend函数

容器中,begin和end返回的具体类型由对象是否是常量决定,如果对象是常量,它们返回的是const_iterator;如果对象不是常量，则返回iterator。

```c++
vector<int> v;
const vector<int> cv;
auto it1 = v.begin();  //--it1的返回类型是vector<int>::iterator
auto it2 = cv.begin(); //--it2的返回类型是vector<int>::const_iterator
```
有时候这种默认的行为并不是我们想要的,有时只想要常量类型。为了便于专门得到const_iterator类型的返回值，c++11中引入了两个新函数，分别是cbegin(),cend()。不论容器对象本身是否是常量，返回值都是const_iterator。

# 11. 标准库函数begin和end
使用指针遍历数组时，为了方便首尾指针，c++11中引入两个名为begin和end的库函数，这两个函数与容器中的两个同名成员功能相似，但是使用数组作为它们的参数。

```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9};
int * beg = begin(ia);  //--指向ia首元素地址
int * last = end(ia);	//--指向ia尾元素的下一位置的地址
```

# 12. 将sizeof用于类成员

C++11新标准允许我们使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问类的成员，但是sizeof无须我们提供一个具体的对象，因为要想知道类成员的大小无须真的获取该成员。

```c++

class Sales_data 
{
public:
	int revenue;
};

auto n = sizeof Sales_data::revenue;
```

# 13. 标准库initializer_list类

如果函数的实参数量未知但是全部实参的类型都相同时，可以使用initializer_list类型的形参，实现可变长参数函数。initializer_list是一种模版类型，定义initializer_list对象时，必须指明列表中所含元素的类型。而且initializer_list对象中的元素永远是常量值。

```c++
void error_msg(initializer_list<string> il) 
{
	for (auto & i:il) 
	{
		cout << i.c_str() << " ";
	}

	cout << endl;
}

error_msg({"level1 ","level2","level3"});  //--调用方式

```

# 14. 列表初始化返回值

c++11新标准规定，函数可以返回花括号包围的值的列表。类似于其它返回结果，此处的列表也用来对表示函数返回值的临时量进行初始化。如果列表为空，临时量执行初始化；否则，返回的值由函数的返回类型决定。

```c++
vector<string> process(int type) 
{

	if (0==type) 
	{
		return{ "type0" };
	}
	else 
	{
		return{ "type1", "type 2", "type 3" };
	}
}

```

如果函数返回的值是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。


# 15. 尾置返回类型

有点鸡肋。

# 16. constexpr函数

constexpr函数是指能用于constexpr表达式的函数。遵循：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条语句。

```c++
constexpr int new_sz() { return 42; }

constexpr int foo = new_sz();  //--常量表达式
```

允许constexpr函数的返回值并非一个常量：

```c++
constexpr int new_sz() { return 42; }
constexpr size_t scale(size_t cnt) { return new_sz()*cnt; }

int arr[scale(2)];  //--正确
int i = 2;
int arr2[scale(i)];  //--错误：scale(i)不是常量表达式
```

当scale的实参是常量表达式时，返回值也是常量表达式，反之则不然。

# 17. 使用=default生成默认构造函数

c++中，如果我们为一个类已经定义了其他构造函数，那么也必须定义一个默认构造函数。在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上=default来要求编译器生成默认构造函数。

# 18. 委托构造函数

C++新标准扩展了构造函数初始值的功能，称做委托构造函数。一个委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程，或者说它把自己的一些（或全部）职责委托给了其他构造函数。

如：
```c++

class Sales_data
{
public:

	Sales_data(string s,unsigned cnt,double price) {}

	Sales_data() :Sales_data("",0,0) {}

	Sales_data(string s) :Sales_data(s,0,0) {}

	Sales_data(double price) :Sales_data() {}
};
```

当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行，然后控制权交还给委托者的函数体。


# 19. constexpr构造函数

TO DO。。。


# 20. array和forward_list顺序容器

常用的顺序容器有：

+ vector  可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢
+ deque  双端队列，支持快速随机访问，在头尾位置插入或删除速度很快
+ list   双向链表，只支持双向顺序访问，在任何位置进行插入/删除操作都很快
+ string 与vector相似的容器，但专门用于保存字符
  
另外c++11新增了两个容器：
+ forward_list 单向链表，只支持单向顺序访问，在任何位置进行插入/删除操作都很快
+ array 固定大小数组，支持快速随机访问，不能添加和删除元素

通常，使用vector是最好的选择，除非你有很好的理由选择其它容器。如程序要求在容器的中间插入或删除元素，可使用list或forward_list。

# 21. 容器的非成员函数swap

从c++11起，提供泛化版的swap函数。swap操作交换两个相同类型容器的内容。
注意：
除array以外，swap不对任何元素进行拷贝、删除或插入操作。swap只是交换了两个容器的内部数据结构。

# 22. 使用insert的返回值

在旧版本的标准库中，insert操作的返回值是void，新版本返回指向第一个新加入元素的迭代器。


# 23. 使用emplace操作

新标准引入3个新成员——emplace_front,emplace,emplace_back。这些操作构造而不是拷贝元素。这些操作分别对应push_front,insert,push_back，允许把元素放在容器头部，一个指定位置之前或容器尾部。
当调用push或insert时把元素类型的对象传递给它们，这些对象被拷贝到容器中。
而当调用一个emplace成员时，则是将参数传递给元素类型的构造函数，emplace成员使用这些参数在容器管理的内存空间中直接构造元素。需注意，参数必须与元素类型的构造函数匹配。


# 24. shrink_to_fit函数

在新标准库中，可以调用shrink_to_fit来要求deque，vector，或string退回不需要的内存空间。此函数指出我们不需要多余的内存空间，但是，具体的实现可以忽略此请求，调用shrink_to_fit也并不保证一定退回内存空间。

# 25. lambda表达式

新标准中引入了lambda表达式，一个lambda表达式表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数。与任何函数类似，一个lambda具有一个返回类型，一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部，一个lambda表达式形式为：

```
[capture list] (parameter list) -> return type { function body }
```
其中capture list是一个lambda所在函数中定义的局部变量的列表（通常为空），return type,parameter list,function body与任何普通函数一样。

可以忽略参数列表和返回值类型，但必须永远包含捕获列表和函数体：

```
auto f = [] {return 42; };
```

忽略括号和参数列表等价于指定一个空参数列表。如果忽略返回类型，lambda根据函数体中的代码推断出返回类型，如果没有return语句，则返回类型为void。

一个lambda通过将局部变量包含在其捕获列表中使用这些变量，捕获列表指引lambda在其内部包含访问局部变量所需的信息。

# 26. 标准库bind函数

新标准中引入bind函数，进行参数绑定。可以将bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。
调用bind的一般形式为：

```
auto newCallable=bind(callable,arg_list)
```

其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list。arg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是占位符，表示newCallabel的参数，它们占据了传递给newCallable的参数的“位置”。如：_1为newCallable的第一个参数，_2为第二个参数，依此类推。

如：
```c++
void f_be_bind(int a,int b ,int c,int d ,int e) 
{

	cout << "a:"<<a<<" ,b:"<<b<<",c:"<<c<<",d:"<<d<<",e:"<<e <<endl;
}

auto f_bind = bind(f_be_bind,1,_2,3,4,_1);

	f_bind(5, 2);

```

f_be_bind有5个参数，第一个参数被绑定为1，第三个参数被绑定为3，第四个参数为4，而第二个参数被绑定为新函数对象的第二个参数，第五个参数被绑定为新函数对象的第一个参数。

须知,_1,_2等占位符，在std::placeholders名字空间使用。

  
# 27. 无序容器

c++11提供了四种无序容器：

+ unordered_map
+ unordered_set
+ unordered_multimap
+ unordered_multiset

无序容器和有序容器有相同的操作，无序容器使用哈希函数进行组织，而普通容器使用红黑树进行组织。

# 28. 智能指针

为了更容易，也更安全的使用动态内存，新的标准中提供了两种智能指针类型为管理动态对象。shared_ptr允许多个指针指向同一个对象，unique_ptr则“独占”所指向的对象。

shared_ptr和unique_ptr实际上是模版类，分别结合make_shared和make_unique模版函数，能消除显示的new,delete操作。

注:make_unique是在C++14里引入的。

还有一个为了在特定场合使用的weak_ptr指针。weak_ptr是一种不控制所指向对象生存周期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数.一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放,即使有weak_ptr指向对象。

weak_ptr的使用场合可以参考文章：

[智能指针](https://www.jianshu.com/p/bf8de014e5c2)

使用shared_ptr可能因循环引用而导致内存泄露，可以使用weak_ptr对资源时行监控。

# 29. 将=default用于拷贝控制成员

我们可以通过将拷贝控制成员定义为=default来显示的要求编译器生成合成（默认）的版本。

```c++

class SalesData 
{
public:
	SalesData() = default; //--内联函数

	SalesData(const SalesData &) = default;

	SalesData & operator=(const SalesData &);

	~SalesData() = default;
};

SalesData & SalesData::operator=(const SalesData &) = default;  //--非内联函数

```

当在内中使用 = default修饰时,合成函数隐式声明为内联的，如果想不为内联，应该在类外定义。

对于拷贝构造函数，拷贝赋值运算符和析构函数，C++语言并不要求我们定义所有这些操作。那怎么决定是否定义？

+ 需要析构函数的类也需要定义拷贝和赋值操作
  
  通常，是否需要析构函数会很明显，如需要释放动态申请的内存。如果一个类需一个析构函数时，几乎可以肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。因为，通常意味着有引用类型，需要深层拷贝。 

+ 需要拷贝操作的类也需要赋值操作，反之亦然
  
  如果一个类需要拷贝构造函数，几乎可以肯定需要拷贝赋值运算符，反之亦然。但是不一定需要析构函数。


# 30. 使用=delete阻止拷贝类对象

虽然大多数类应该定义拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。为了阻止拷贝，看起来可能应该不定义拷贝控制成员。但是，这种策略是无效的：如果我们的类未定义这些操作，编译器为它生成默认的版本。

在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数(deleted function)来阻止拷贝。删除的函数是指:我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加在=delete来指出我们希望将它定义成为删除的：

```c+++
class NoCopy 
{
	NoCopy() = default;
	NoCopy(const NoCopy &) = delete; //--阻止拷贝
	NoCopy  & operator =(const NoCopy &) = delete; //--阻止赋值
	~NoCopy() = default;
};
```
需要注意：

+ 与=default不同，=delete必须出现在函数第一次声明的时候；
+ 与=default不同，我们可以对任何函数指定=delete，虽然删除函数主要用途是用来阻止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的；
+ 不能删除析构函数，如果析构函数被删除，就无法销毁此类型的对象了；
+ 在新标准之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝。

# 31. 用移动类对象来代替拷贝类对象

假设我们自己要为一个string数组写一个重新分配内存的成员函数，忽略具体细节，它应该：
+ 为一个新的、更大的string数组分配内存
+ 在内存空间的前一部分构造对象，保存现有元素
+ 销毁原内存空间中的元素，并释放这块内存
  
可以看到，重新分配内存空间时，会把string从旧内存空间拷贝到新内存空间，而string具有类值行为，拷贝时会有两个副本，而拷贝完后再删除原有副本。因此，拷贝这些string中的数据是多余的，在重新分配内存空间时，如果我们避免分配和释放string的开销，性能会有很大提升。

通过使用新标准库引入的两种机制，我们可以避免string的拷贝。

+ 第一个机制：移动构造函数

有一些标准类库，包括string，都定义了所谓的”移动构造函数“。移动构造函数如何工作和具体实现细节都未公布。但是，移动构造函数通常是将资源从给定对象”移动“而不是拷贝到正在创建的对象。而且，标准库保证”移后源“(moved-from)仍然保持一个有效的，可析构状态。对于string，可以想象每个string都有一个指向char数组的指针。可以假定string的移动构造函数进行了指针的拷贝，而不是为字符分配内存空间然后拷贝字符。

+ 第二个机制：std::move函数

1） 调用move函数表示希望使用移动构造函数，如果漏掉了move调用，将会使用拷贝构造函数； 
2） 通常不会为move调用using声明（TODO,为什么？），使用时，直接调用std::move而不是move。

# 32. 右值引用

为了支持移动操作，新标准引入了一种新的引用类型——右值引用（rvalue reference）。所谓右值引用就是必须绑定到右值的引用，通过&&而不是&获得右值引用。右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。因此，可以自由地将一个右值引用的资源”移动“到另一个对象中。

类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。对于常规引用（为了与右值引用区分，通常称之为左值引用），我们不能把它绑定到要求转换的表达式，字面常量或是返回右值的的表达式。右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上：

```c++
   int i = 42;

	int & r = i;				//--正确

	int && rr = i;				//--错误：不能将一个右值引用绑定到一个左值上，因为变量是左值

	int & r2 = i * 42;			//--错误：非常量引用的初始值必须为左值，而i*42为右值

	const int & r3 = i * 42;	//--正确

	int && rr2 = i * 42;		//--正确

```

考察左值和右值表达式的列表，两者相互区别很明显：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。由于右值引用只能绑定到临时对象，因此我们得知：

+ 所引用的对象将要被销毁；
+ 该对象没有其他用户；

即，使用右值引用的代码可以自由地接管所引用的对象的资源。

变量可以看作只有一个运算对象而没有运算符的表达式，类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值，带来的结果就是，我们不能将一个右值引用绑定到一个右值引用类型的变量上，所有有些经讶：

```c+++
    int && rrr1 = 42;
	int && rrr2 = rrr1;
```


**备注**：左值与右值

C++的表达式要不然是左值要不然是右值，在C语言中：左值可以位于赋值语句的左侧，右值则不能；

在C++语言中，更加难以区分。一个左值表达式的求值结果是一个对象或一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。虽然某些表达式的求值结果是对象，但它们是右值而非左值。可以作一个简单的归纳：当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

# 33. 标准库move函数

虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显示的将一个左值转换为对应的右值引用类型。更合理的是，调用move标准库函数来获得绑定到左值上的右值引用，move函数返回给定对象的右值引用：

```c++

int && rrr3 = std::move(rrr1); //--正确

```

move调用告诉编译器：我们有一个左值，但我们想像右值一样使用它。必须认识到：调用move后就意味着除了对rrr1赋值或销毁它外，我们将不再使用它。在调用move之后，我们不能对移后源对象的值做任何假设。

# 34. 移动构造函数和移动赋值

为了让我们自己的的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符，这两个成员类似对应的拷贝操作，但它们从给定的对象”窃取“资源而不是拷贝资源。类似拷贝构造函数，移动构造函数的第一个参数是该类型的一个引用，不过该引用参数是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须要有默认实参。
除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向移动的资源——这些资源的所有权已经归属新创建的对象。

```c++
class SalesDataVet 
{
public:
	SalesDataVet() = default;
	SalesDataVet(SalesDataVet && s) noexcept	//--移动操作不应抛出任何异常
		:elements(s.elements)
	{
		s.elements = nullptr;					//--源对像必须不再指向被移动的资源
	}
private:
	SalesData * elements;
};
```

# 35. 移动构造函数通常应该是nocxcept

noexcept是新标准中引入的，表示一个函数不会抛出异常。

由于移动构造操作”窃取“资源,通常不会分配任何资源。因此，移动操作通常不会抛出任何异常，而且需要使用noexcept关键字显式通知给标准库。如果不显示通知，标准库会变得”保守“，比如该使用移动的地方而使用了拷贝。

# 36. 移动赋值运算符

移动赋值运算符执行与析构函数和移动构造函数相同的工作，也应该将它标记为noexcept。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：

```c++
class SalesDataVet 
{
public:
	SalesDataVet() = default;
	SalesDataVet(SalesDataVet && s) noexcept	//--移动操作不应抛出任何异常
		:elements(s.elements)
	{
		s.elements = nullptr;					//--源对像必须不再指向被移动的资源
	}

	SalesDataVet & operator=(SalesDataVet && s) noexcept
	{
		if (this != & s)						//--检测自赋值
		{
			delete elements;					//--释放已有元素
			elements = nullptr;

			elements = s.elements;				//--接管资源
			s.elements = nullptr;
		}
		return *this;
	}

private:
	SalesData * elements;
};
```

# 37. 移动迭代器

新标准中定义了一种移动迭代器适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。然而，移动迭代器的解引用运算符生成一个右值引用。
通过调用标准库的make_move_iterator将一个普通迭代器转换为一个移动迭代器。

# 38. 引用限定成员函数

在旧准中，没有办法阻止右值赋值，如：

```c++
    string s1 = "value1";
	string s2 = "value2";
	s1 + s2 = "wow!";
```

此处，对两个字符的连接结果，一个右值进行了赋值。

为了维持向后兼容，新标准仍然允许向右赋值，但是我们可以在自己的类中阻止此类用法，可以强制左侧运算对象（即，this指向的对象）是一个左值；

指定方式与定义const成员函数相同，即，在参数列表后放置一个引用限定符。

引用限定符可以是&或&&,分别指出this可以指向一个左传或右值，类似const限定符，引用限定符只能用于(非static)成员函数，且必须出现在函数的声明和定义中。

```c++
class Foo
{
public:
	Foo sorted() && ;         //--右值限定符，调用对象必须为右值
	Foo sorted() const &;     //--const和左值限定符，调用对象为const或左值

private:
	vector<int> data;
};


//--调用对象为右值，因此可以原址排序
Foo Foo::sorted() &&
{
	sort(data.begin(),data.end());  
	return *this;
}

//--调用对象为const或左值，哪种情况都不能对其进行原址排序
Foo Foo::sorted() const & 
{
	Foo ret(*this);
	sort(ret.data.begin(),ret.data.end()); //--对副本排序
	return ret;
}
```
对象是右值，意味着没有其他用户，因此我们可以改变对象。

注意：如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。

# 39. function类模版

c++中有几种可调用的对象:函数，函数指针，lambda表达式，bind创建的对象以及重载了函数调用运算符的类。使用function类,两个不同类型的可调用对象能够共享同一种调用形式。例如，以前经常用map来存放函数指针,现在除了函数指针，可以把不同形式的可调用对象存放到同一个map中：

```c++
//--普通函数
int add(int a, int b) { return a + b; }

//--lambda函数
auto mod = [](int i, int j) {return i%j; };

//--函数对象类
struct devide 
{
	int operator() (int denominator,int divisor)
	{
		return denominator / divisor;
	}
};

map<string, function<int(int, int)>> binops = 
{
	{"+",add},
	{"-",std::minus<int>{}},
	{"/",devide()},
	{"%",mod}
};
```

# 40. explicit类型转换运算符

TODO..

# 41. 通过定义类为final来阻止继承

有时会定义这样一种类，我们不希望其它类继承它，或者不想考虑它是否适合作为一个基类。c++新标准提供了一种防止继承发生的方法，即在类名后面跟一个关键字final。

```c++
class NoDerived final 
{
  // do something
};
```

# 42. 虚函数的override和final指示符

派生类如果定义了一个函数与基类中的虚函数的名字相同但是形参列表不同，这仍然是合法的行为，编译器认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的版本。在编程实践中,这种声明往往是意味着发生了错误，本意应该是希望派生类的函数覆盖掉基类中的函数。

要调试此类错误非常困难，在C++11中可以使用override关键字来说明派生类的的虚函数，让编译器帮我们发现错误。如果我们使用了override关键字标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错：

```c++
struct B 
{
	virtual void f1(int) const;

	virtual void f2();

	void f3();
};

struct D1 :B 
{
	void f1(int) const override;			//--正确

	void f2(int) override;					//--错误，基类中没有f2(int)的定义

	void f3() override;						//--错误，f3()不是虚函数

	void f4() override;						//--错误，基类中没有f4()定义
};
```

还可以把某个函数指定为final,之后任何尝试覆盖该函数的操作都会引起错误：

```c++
struct B 
{
	virtual void f1(int) const;

	virtual void f2();

	virtual void f3() final;
};


struct D1 :B 
{
	void f1(int) const override final;	
};

struct D2 :D1 
{
	void f1(int) const override;	//--错误，D1中指定为final
	void f2() override;				//--正确
	void f3() override;				//--错误，B中指定为final
};

```

# 43. 继承的构造函数

在C++11新标准中，派生类能够重用其直接基类定义的构造函数。这些构造函数并非以常规的方式继承而来(而是使用using关键字继承)。一个派生类只初始化它的直接基类，同样的原因，一个类也只继承其直接基类的构造函数，类不能继承默认、拷贝和移动构造函数。

```c++
class Disc_quote 
{
public:
	Disc_quote(const string & book,double price);

};

class Bulk_quote:Disc_quote 
{
public:
	using Disc_quote::Disc_quote; //--继承自Disc_quote的构造函数
};
```

通常情况下，using关键字只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。上面的例子中，等价于编译器生成了一个构造函数：

```c++
Bulk_quote(const string & book, double price) :Disc_quote(book, price) {}
```

如果派生类有自己的成员，则这些成员将被默认初始化。

# 44. 声明模版类型形参为友元

在新标准中，我们可以将模版类型参数声明为友元：

```c++
template <template Type> 
class Bar 
{
	friend Type;      //--将访问权限授予用来实例化bar的类型
};
```

对于某个类型名为Foo,Foo将成为Bar<Foo>的友元，SalesData将成为Bar<SalesData>的友元。

# 45. 模版类型别名

类模版的一个实例定义了一个类型，因此可以定义一个typedef来引用实例化的类：

```c++
typedef Bob<string> StrBob;
```

但是，由于一个模版不是一个类型，我们不能定义一个typedef引用一个模版，即，无法定义：

```c++
typedef Bob<T> TBob;
```

但是，新标准中允许我们为类模版定义一个类型别名:

```c++
template <template T> using twin = pair<T,T>;
```

我们将twin定义为成员类型相同的pair的别名，这样twin的用户只需指定一次类型：

```c++
twin<string> authors; //--等价于pair<string,string> authors;
twin<int> price;      //--等价于pair<int,int> price;
```

# 46. 模版函数的默认模版参数

就像我们能为函数参数提供默认参数一样，我们也可以提供默认模版实参。在新标准中,我们可以为函数和类模版提供默认实参。而更早的C++标准只允许为类模版提供默认实参。

```c++
//--compare有一个默认模板实参less<T>和一个默认函数实参F()
template <template T,template F=less<F>>
int compare(const T & v1,const T & v2,F f=F())  
{

}
```

