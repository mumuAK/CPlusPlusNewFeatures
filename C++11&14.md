# C++NewFeatures

## long long类型
长整型，最小64位。

##列表初始化 
以花括号的方式进行初始化。
通常C++的几种不同的初始化方式可以相互等价的使用。但如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。
```c++
std::vector<std::string> v1{"a","an","the"};   //--正确
std::vector<std::string> v2( "a","an","the" ); //--错误
```

##空指针
空指针不使用任何对象，几个生成空指针的方法：
```c++
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;
```
最直接的方法是用字面值nullptr来初始化指针，C++11新标准中引入的方法。nullptr指针是一种特殊类型的字面值，可以被转换成任意其他的指针类型。

##constexpr与常量表达式

常量表达式（const expression）是指值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。

常量表达式：
```c++
const int max_files = 20;
const int limit = max_files + 1;
```

非常量表达式：
```c++
int staff_size = 20;
const int sz = get_size();
```
尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而不是const int，所以它不属于常量表达式。另外，尽管sz本身是一个常量，但它的具体值要到运行时才能获取到，所以也不是常量表达式。

constexpr变量
在一个复杂系统中，很难（几乎不可能）分辨一个初始值到底是不是一个常量表达式。c++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

```c++
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz = size(); //--当size()是一个constexpr函数时才是一条正确的声明
```

常量表达式的值需要在编译时就计算得到，声明constexpr时用到的类型必须为“字面值类型”。基本数据类型，算术类型，引用和指针都属于字面值类型。

尽管指针和引用都能定义成constexpr，但它们的初始值受到严格限制。一个constexpr指针的初始值必须是nullptr或者0或者存储于某个固定地址中的对象。

##类型别名声明

类型别名(type alias)是一个名字，它是某种类型的同义词。
有两种方法可用于定义类型别名，传统的方法是使用关键字 typedef:

```c++
typedef double wages;	//--wages是double的同义词
typedef wages base, *p;	//--base是double的同义词，p是double *的同义词
```
新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名：
```c++
using SI = Sales_item;  //--SI是Sales_item的同义词
```

## auto类型说明符
编程时常常需要把表达式的值赋值给变量，这就要求在声明变量的时候，清楚的知道表达式的类型。然而做到这一点并不容易，为了解决这个问题c++新标准引入了auto类型说明符，用它让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型。
编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当的改变结果类型，使其更符合初始化规则。

首先，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时，编译器以引用对象的类型作为auto类型：

```c++
int i = 0, &r = i;
auto a = r; //--a是一个整数
```

其次，auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时：

```c++
const int ci = i, &cr = ci;
auto b = ci;	//--b是一个整数（ci的顶层const特性被忽略掉了）
auto c = cr;    //--c是一个整数（cr是ci的别名，ci本身是一个顶层const）
auto d = &i;    //--d是整型指针
auto e = &ci;   //--e是一个指向整数常量的指针（对常量对象取对象是一种底层const）
```
如果希望推倒出来的auto类型是一个顶层const，需要明确指出：

```c++
const auto f = ci; //--ci的推演类型是int，f是const int
```

还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：

```c++
auto & g = ci;			//--g是一个整型常量引用，绑定到ci
auto & h = 42;			//--错误：不能为非常量引用绑定字面值
const auto & j = 42;	//--正确：可以为常量引用绑定字面值
```

要在一条语句中定义多个变量时，切记，符号&和*只从属于某个声明符，而非基本数据类型的一部分，因此，初始值必须是同一种类型。

```c++
auto k = ci, &l = i;     //--k是整数，l是整型引用
auto &m = ci, *p = &ci;  //--m是对整型常量的引用，p是指向整型常量的指针
auto &n = i, *p2 = &ci;  //--错误:i的类型是int，而&ci的类型是const int
```
注：
顶层const与底层const:
指针本身是一个对象，它又可以指向另外一个对象。因此指针是不是一个常量及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const(top-level const)表示指针本身是一个常量，用名词底层const(low-level const)表示指针所指的对象是一个常量。

## decltype类型指示符
有时希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。

```c++
decltype(f()) sum = x; //--sum的类型就是函数f()的返回类型
```

## 类内初始化
C++新标准规定，可以为数据成员提供一个类内初始化值，创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。需要注意的是，初始化时，或者放在花括号里，或者放在等号右边，不能使用圆括号。

## 范围for语句
C++11使用范围for语句遍历给定序列中的每个元素，并对序列中的每个值执行某种操作，语法形式为：
```c++
for(declaration:expression)
   statement
```

其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。

## 容器的cbegin和cend函数

容器中,begin和end返回的具体类型由对象是否是常量决定,如果对象是常量,它们返回的是const_iterator;如果对象不是常量，则返回iterator。

```c++
vector<int> v;
const vector<int> cv;
auto it1 = v.begin();  //--it1的返回类型是vector<int>::iterator
auto it2 = cv.begin(); //--it2的返回类型是vector<int>::const_iterator
```
有时候这种默认的行为并不是我们想要的,有时只想要常量类型。为了便于专门得到const_iterator类型的返回值，c++11中引入了两个新函数，分别是cbegin(),cend()。不论容器对象本身是否是常量，返回值都是const_iterator。

## 标准库函数begin和end
使用指针遍历数组时，为了方便首尾指针，c++11中引入两个名为begin和end的库函数，这两个函数与容器中的两个同名成员功能相似，但是使用数组作为它们的参数。

```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9};
int * beg = begin(ia);  //--指向ia首元素地址
int * last = end(ia);	//--指向ia尾元素的下一位置的地址
```

## 将sizeof用于类成员

C++11新标准允许我们使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问类的成员，但是sizeof无须我们提供一个具体的对象，因为要想知道类成员的大小无须真的获取该成员。

```c++

class Sales_data 
{
public:
	int revenue;
};

auto n = sizeof Sales_data::revenue;
```

## 标准库initializer_list类

如果函数的实参数量未知但是全部实参的类型都相同时，可以使用initializer_list类型的形参，实现可变长参数函数。initializer_list是一种模版类型，定义initializer_list对象时，必须指明列表中所含元素的类型。而且initializer_list对象中的元素永远是常量值。

```c++
void error_msg(initializer_list<string> il) 
{
	for (auto & i:il) 
	{
		cout << i.c_str() << " ";
	}

	cout << endl;
}

error_msg({"level1 ","level2","level3"});  //--调用方式

```

## 列表初始化返回值

c++11新标准规定，函数可以返回花括号包围的值的列表。类似于其它返回结果，此处的列表也用来对表示函数返回值的临时量进行初始化。如果列表为空，临时量执行初始化；否则，返回的值由函数的返回类型决定。

```c++
vector<string> process(int type) 
{

	if (0==type) 
	{
		return{ "type0" };
	}
	else 
	{
		return{ "type1", "type 2", "type 3" };
	}
}

```

如果函数返回的值是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。


## 尾置返回类型

有点鸡肋。

## constexpr函数

constexpr函数是指能用于constexpr表达式的函数。遵循：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条语句。

```c++
constexpr int new_sz() { return 42; }

constexpr int foo = new_sz();  //--常量表达式
```

允许constexpr函数的返回值并非一个常量：

```c++
constexpr int new_sz() { return 42; }
constexpr size_t scale(size_t cnt) { return new_sz()*cnt; }

int arr[scale(2)];  //--正确
int i = 2;
int arr2[scale(i)];  //--错误：scale(i)不是常量表达式
```

当scale的实参是常量表达式时，返回值也是常量表达式，反之则不然。

## 使用=default生成默认构造函数

c++中，如果我们为一个类已经定义了其他构造函数，那么也必须定义一个默认构造函数。在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上=default来要求编译器生成默认构造函数。

## 委托构造函数

C++新标准扩展了构造函数初始值的功能，称做委托构造函数。一个委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程，或者说它把自己的一些（或全部）职责委托给了其他构造函数。

如：
```c++

class Sales_data
{
public:

	Sales_data(string s,unsigned cnt,double price) {}

	Sales_data() :Sales_data("",0,0) {}

	Sales_data(string s) :Sales_data(s,0,0) {}

	Sales_data(double price) :Sales_data() {}
};
```

当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行，然后控制权交还给委托者的函数体。


## constexpr构造函数

TO DO。。。


## array和forward_list顺序容器

常用的顺序容器有：

+ vector  可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢
+ deque  双端队列，支持快速随机访问，在头尾位置插入或删除速度很快
+ list   双向链表，只支持双向顺序访问，在任何位置进行插入/删除操作都很快
+ string 与vector相似的容器，但专门用于保存字符
  
另外c++11新增了两个容器：
+ forward_list 单向链表，只支持单向顺序访问，在任何位置进行插入/删除操作都很快
+ array 固定大小数组，支持快速随机访问，不能添加和删除元素

通常，使用vector是最好的选择，除非你有很好的理由选择其它容器。如程序要求在容器的中间插入或删除元素，可使用list或forward_list。

## 容器的非成员函数swap

从c++11起，提供泛化版的swap函数。swap操作交换两个相同类型容器的内容。
注意：
除array以外，swap不对任何元素进行拷贝、删除或插入操作。swap只是交换了两个容器的内部数据结构。

## 使用insert的返回值

在旧版本的标准库中，insert操作的返回值是void，新版本返回指向第一个新加入元素的迭代器。


## 使用emplace操作

新标准引入3个新成员——emplace_front,emplace,emplace_back。这些操作构造而不是拷贝元素。这些操作分别对应push_front,insert,push_back，允许把元素放在容器头部，一个指定位置之前或容器尾部。
当调用push或insert时把元素类型的对象传递给它们，这些对象被拷贝到容器中。
而当调用一个emplace成员时，则是将参数传递给元素类型的构造函数，emplace成员使用这些参数在容器管理的内存空间中直接构造元素。需注意，参数必须与元素类型的构造函数匹配。




  
